import streamlit as st
import pandas as pd
import sqlite3
import json
from supabase import create_client

def init_supabase():
    """Inicializa o cliente Supabase usando as credenciais do Streamlit secrets"""
    try:
        url = st.secrets["SUPABASE_URL"]
        key = st.secrets["SUPABASE_KEY"]
        return create_client(url, key)
    except Exception as e:
        st.error(f"Erro ao conectar com Supabase: {str(e)}")
        return None

def get_sqlite_data(table_name, db_path="financas.db"):
    """Obtém dados de uma tabela específica do SQLite"""
    try:
        conn = sqlite3.connect(db_path)
        # Usar pandas para facilitar a visualização
        df = pd.read_sql_query(f"SELECT * FROM {table_name}", conn)
        conn.close()
        return df
    except Exception as e:
        st.error(f"Erro ao ler tabela {table_name}: {str(e)}")
        return None

def fix_schema_issues():
    """Corrige problemas de schema no Supabase diretamente via SQL"""
    supabase = init_supabase()
    if not supabase:
        return False
    
    # Script SQL para corrigir tabelas problemáticas
    fix_scripts = {
        "goals": """
        -- Recriar tabela goals com a estrutura correta
        DROP TABLE IF EXISTS goals CASCADE;
        CREATE TABLE goals (
            id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            title TEXT NOT NULL,
            description TEXT,
            target_amount DECIMAL(12,2) NOT NULL,
            current_amount DECIMAL(12,2) DEFAULT 0,
            deadline TEXT,
            category TEXT,
            status TEXT DEFAULT 'Em Andamento',
            created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
        );
        CREATE INDEX idx_goals_title ON goals(title);
        """,
        
        "reminders": """
        -- Recriar tabela reminders
        DROP TABLE IF EXISTS reminders CASCADE;
        CREATE TABLE reminders (
            id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            user_id BIGINT,
            transaction_id BIGINT,
            reminder_date TEXT,
            status TEXT
        );
        CREATE INDEX idx_reminders_user_id ON reminders(user_id);
        CREATE INDEX idx_reminders_transaction_id ON reminders(transaction_id);
        """,
        
        "user_settings": """
        -- Recriar tabela user_settings
        DROP TABLE IF EXISTS user_settings CASCADE;
        CREATE TABLE user_settings (
            id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            user_id BIGINT,
            settings TEXT NOT NULL,
            created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
        );
        """
    }
    
    for table_name, script in fix_scripts.items():
        try:
            # Executar script diretamente via SQL
            response = supabase.query(script).execute()
            st.success(f"Schema da tabela {table_name} recriado com sucesso!")
        except Exception as e:
            st.error(f"Erro ao recriar tabela {table_name}: {str(e)}")
            return False
    
    return True

def fix_and_upload_table(table_name):
    """Corrige e envia dados para uma tabela específica"""
    supabase = init_supabase()
    if not supabase:
        return False
    
    # Obter dados do SQLite
    df = get_sqlite_data(table_name)
    if df is None or df.empty:
        st.warning(f"Nenhum dado encontrado na tabela {table_name} do SQLite")
        return False
    
    st.write(f"Dados da tabela {table_name} do SQLite:")
    st.dataframe(df)
    
    # Converter para o formato adequado ao Supabase
    records = df.to_dict(orient='records')
    
    # Fazer ajustes específicos por tabela
    if table_name == 'goals':
        for record in records:
            # Garantir que todos os campos necessários estejam presentes
            if 'updated_at' not in record or record['updated_at'] is None:
                record['updated_at'] = record.get('created_at', pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S'))
            
            # Converter tipos de dados conforme necessário
            for key, value in list(record.items()):
                if pd.isna(value):
                    if key in ['description', 'category', 'status']:
                        record[key] = ''
                    elif key in ['current_amount']:
                        record[key] = 0.0
    
    # Enviar dados para o Supabase
    try:
        # Limpar tabela existente
        supabase.table(table_name).delete().neq('id', 0).execute()
        
        # Inserir novos dados
        if records:
            # Dividir em lotes para evitar problemas
            batch_size = 10
            for i in range(0, len(records), batch_size):
                batch = records[i:min(i+batch_size, len(records))]
                response = supabase.table(table_name).insert(batch).execute()
        
        st.success(f"✅ Dados da tabela {table_name} migrados com sucesso!")
        return True
    except Exception as e:
        st.error(f"Erro ao migrar dados para {table_name}: {str(e)}")
        
        # Tentar inserir um por um para identificar erros específicos
        for record in records:
            try:
                supabase.table(table_name).insert(record).execute()
            except Exception as item_e:
                st.error(f"Erro no registro {record.get('id', 'desconhecido')}: {str(item_e)}")
                st.write("Registro problemático:", record)
        
        return False

def show_fix_interface():
    st.title("Correções Manuais para Migração")
    
    st.info("""
    ### Correções Manuais para Problemas de Migração
    
    Esta ferramenta ajudará a resolver problemas específicos nas tabelas que 
    não puderam ser migradas automaticamente.
    """)
    
    # Verificar conexão com Supabase
    supabase = init_supabase()
    if not supabase:
        st.error("Não foi possível conectar ao Supabase. Verifique suas credenciais.")
        return
    
    # Etapa 1: Corrigir esquemas
    st.subheader("Etapa 1: Corrigir Esquemas das Tabelas")
    if st.button("Corrigir Esquemas"):
        if fix_schema_issues():
            st.success("✅ Esquemas das tabelas corrigidos com sucesso!")
        else:
            st.error("❌ Ocorreram erros na correção dos esquemas.")
    
    st.divider()
    
    # Etapa 2: Migrar dados específicos
    st.subheader("Etapa 2: Migrar Dados por Tabela")
    
    problem_tables = ["goals", "reminders", "user_settings"]
    
    # Permitir que o usuário escolha qual tabela corrigir
    table_to_fix = st.selectbox(
        "Escolha a tabela para corrigir",
        problem_tables
    )
    
    if st.button(f"Migrar dados da tabela {table_to_fix}"):
        fix_and_upload_table(table_to_fix)
    
    st.divider()
    
    # Etapa 3: Verificar aplicativo
    st.subheader("Etapa 3: Verificar Aplicativo")
    st.info("""
    Após corrigir todas as tabelas, execute seu aplicativo principal para verificar se ele 
    está funcionando corretamente com o Supabase.
    
    ```
    streamlit run run.py
    ```
    
    Se tudo estiver funcionando, não se esqueça de atualizar as configurações no Streamlit Cloud 
    para usar o Supabase.
    """)
    
if __name__ == "__main__":
    show_fix_interface()
